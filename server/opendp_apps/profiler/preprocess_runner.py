from __future__ import print_function
import json, time, datetime
from collections import OrderedDict
import decimal
import pandas as pd

from .conversions import conversions
from .col_info_constants import SELF_SECTION_KEY, DATA_SOURCE_INFO, DATASET_CITATION, VARIABLES_SECTION_KEY, \
    DATASET_LEVEL_KEY, VARIABLE_DISPLAY_SECTION_KEY
from .np_json_encoder import NumpyJSONEncoder
from .type_guess_util import TypeGuessUtil
from .summary_stats_util import SummaryStatsUtil
from .column_info import ColumnInfo
from .plot_values import PlotValuesUtil
from .variable_display_util import VariableDisplayUtil
from .dataset_level_info_util import DatasetLevelInfo

KEY_JSONLD_CITATION = 'jsonld_citation'


class PreprocessRunner(object):
    """Preprocess relatively small files using pandas"""

    def __init__(self, dataframe, **kwargs):
        """
        Init with a pandas dataframe

        :param dataframe:
        :param kwargs:
        """
        self.data_frame = dataframe
        self.job_id = kwargs.get('job_id', None)

        # for a json_ld citation from dataverse
        self.jsonld_citation = kwargs.get(KEY_JSONLD_CITATION, None)
        self.schema_info_dict = kwargs.get('SCHEMA_INFO_DICT', None)

        # for data source
        self.data_source_info = kwargs.get('data_source_info')

        self.celery_task = kwargs.get('celery_task')
        # to populate
        self.variable_info = {}  # { variable_name: ColumnInfo, ...}
        self.num_vars = None
        self.num_vars_complete = None

        # for error handling
        self.has_error = False
        self.error_message = None
        time_stamp = time.time()
        self.current_time = datetime.datetime.fromtimestamp(time_stamp) \
            .strftime('%Y-%m-%d %H:%M:%S')
        self.preprocess_id = None
        self.user_vars = kwargs.get('user_vars')
        self.run_preprocess()

    def add_error_message(self, err_msg):
        """Add error message"""
        # print(err_msg)
        self.has_error = True
        self.error_message = err_msg

    def run_preprocess(self):
        """Run preprocess"""
        if not isinstance(self.data_frame, pd.DataFrame):
            self.add_error_message('The dataframe is not valid')
            return False

        if not self.calculate_features():
            return False

        return True

    def calculate_features(self):
        """For each variable, calculate summary stats"""
        if self.has_error:
            return False
        # Iterate through data frame and
        # run type guess, cal_stats, and plot_values on each ColumnInfo object
        #
        self.num_vars = len(self.data_frame.columns)
        self.num_vars_complete = 0

        for colnames in self.data_frame:
            # set stats for each column
            col_info = ColumnInfo(colnames)
            col_series = self.data_frame[colnames]

            type_guess_util = TypeGuessUtil(col_series, col_info, user_vars=self.user_vars)
            if type_guess_util.has_error():
                self.add_error_message(type_guess_util.get_error_message())
                return

            SummaryStatsUtil(col_series, col_info)
            PlotValuesUtil(col_series, col_info)
            # VariableDisplayUtil(col_series, col_info)
            # assign object info to the variable_info
            #
            self.num_vars_complete += 1
            self.variable_info[colnames] = col_info

        # print("completed column", self.num_vars_complete)
        # print(" Number of variable ", self.num_vars)
        return True

    def get_self_section(self):
        """
        {
          "self": {
            "description": "TwoRavens metadata generated by https://github.com/TwoRavens/raven-metadata-service",
            "created_at": "current timestamp", # job.modified when done via the web
        },
        """
        self_section = OrderedDict()
        self_section['created_at'] = self.current_time

        if self.schema_info_dict:
            self_section['schema'] = self.schema_info_dict

        return self_section

    def get_dataset_level_info(self):
        """
        "dataset": {
       "row_cnt": 1000,
       "variable_cnt": 25
                }
        """
        dataset_level_info = DatasetLevelInfo(self.data_frame)
        if dataset_level_info.has_error:
            info_dict = OrderedDict()
            info_dict["error"] = dataset_level_info.error_messages
            return info_dict

        info_dict = dataset_level_info.final_output
        if self.data_source_info:
            info_dict[DATA_SOURCE_INFO] = self.data_source_info.as_dict()

        if self.jsonld_citation:
            info_dict[DATASET_CITATION] = self.jsonld_citation
            # info_dict[DATA_SOURCE_INFO][DATASET_CITATION] = \
            #    self.jsonld_citation

        return info_dict

    def show_final_info(self, old_format=False):
        """Print the final info to the screen"""
        if self.has_error:
            err_msg = 'An error occurred earlier in the process:\n%s' % \
                      self.error_message
            print(err_msg)
            return

        info_string = self.get_final_dict(as_string=True, old_format=old_format)

        print(info_string)

    def get_final_json_indented(self, indent=4):
        """Return the final variable info as a JSON string"""
        if self.has_error:
            err_msg = 'An error occurred earlier in the process:\n%s' % \
                      self.error_message
            print(err_msg)
            return

        return self.get_final_dict(as_string=True,
                                   indent=indent)

    def get_final_json(self, indent=None, old_format=False):
        """Return the final variable info as a JSON string"""
        if self.has_error:
            err_msg = 'An error occurred earlier in the process:\n%s' % \
                      self.error_message
            print(err_msg)
            return

        return self.get_final_dict(as_string=True, indent=indent, old_format=old_format)

    def convert(self, data, old_format):
        """Convert from new to old format"""
        if not old_format:
            return data

        out = OrderedDict()
        for k, v in data.items():
            conv = conversions.get(k)
            if conv and not conv[0]:
                continue
            elif conv:
                out[conv[0]] = conv[1](v) if len(conv) == 2 else v
            else:
                out[k] = v

        out['varnamesTypes'] = out['varnamesSumStat']
        out['defaultInterval'] = out['interval']
        out['defaultNumchar'] = out['numchar']
        out['defaultNature'] = out['nature']
        out['defaultBinary'] = out['binary']

        if out['plotvalues']:
            out['plottype'] = 'bar'

        for x in ('plotx', 'ploty', 'plotvalues'):
            if out[x] is None or not len(out[x]):
                del out[x]

        return out

    def get_final_dict(self, as_string=False, old_format=False, **kwargs):
        """Return the preprocess data as an OrderedDict"""
        if self.has_error:
            err_msg = 'An error occurred earlier in the process:\n%s' % \
                      self.error_message
            print(err_msg)
            return

        fmt_variable_info = OrderedDict()  # capture the variables section
        fmt_display_variable_info = OrderedDict()  # capture the variable_display section
        fmt_display_variable_info['editable'] = ColumnInfo.get_editable_column_labels()

        # Iterate through each column and pull variable + variable_display info
        for col_name, col_info in self.variable_info.items():
            # col_info.print_values()
            fmt_variable_info[col_name] = self.convert(col_info.as_dict(), old_format)
            if not old_format:
                fmt_display_variable_info[col_name] = VariableDisplayUtil.get_default_settings()

        desc = self.get_dataset_level_info()

        # Format the entire document
        overall_dict = OrderedDict()
        if old_format:
            overall_dict['dataset'] = {
                "private": False,
            }
            overall_dict[VARIABLES_SECTION_KEY] = fmt_variable_info
        else:
            overall_dict[
                '$schema'] = 'https://github.com/TwoRavens/raven-metadata-service/schema/jsonschema/1-2-0.json#'
            overall_dict[SELF_SECTION_KEY] = self.get_self_section()
            overall_dict[DATASET_LEVEL_KEY] = desc
            overall_dict[VARIABLES_SECTION_KEY] = fmt_variable_info
            overall_dict[VARIABLE_DISPLAY_SECTION_KEY] = fmt_display_variable_info

        if as_string:
            # Convert the OrderedDict to a JSON string
            indent_level = kwargs.get('indent', 4)
            if indent_level is None:
                pass
            elif (not isinstance(indent_level, int)) or indent_level > 50:
                indent_level = 4

            return json.dumps(overall_dict,
                              indent=indent_level,
                              cls=NumpyJSONEncoder)

        # w/o this step, a regular json.dumps() fails on the returned dict
        jstring = json.dumps(overall_dict, cls=NumpyJSONEncoder)
        return json.loads(jstring,
                          object_pairs_hook=OrderedDict,
                          parse_float=decimal.Decimal)
